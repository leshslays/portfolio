{"ast":null,"code":"import mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nconst msPerFrame = 1000 / 60;\nexport default class Motion extends React.Component {\n  constructor(props) {\n    super(props);\n    this.unmounting = false;\n    this.wasAnimating = false;\n    this.animationID = null;\n    this.prevTime = 0;\n    this.accumulatedTime = 0;\n    this.unreadPropStyle = null;\n\n    this.clearUnreadPropStyle = destStyle => {\n      let dirty = false;\n      let {\n        currentStyle,\n        currentVelocity,\n        lastIdealStyle,\n        lastIdealVelocity\n      } = this.state;\n\n      for (let key in destStyle) {\n        if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n          continue;\n        }\n\n        const styleValue = destStyle[key];\n\n        if (typeof styleValue === 'number') {\n          if (!dirty) {\n            dirty = true;\n            currentStyle = { ...currentStyle\n            };\n            currentVelocity = { ...currentVelocity\n            };\n            lastIdealStyle = { ...lastIdealStyle\n            };\n            lastIdealVelocity = { ...lastIdealVelocity\n            };\n          }\n\n          currentStyle[key] = styleValue;\n          currentVelocity[key] = 0;\n          lastIdealStyle[key] = styleValue;\n          lastIdealVelocity[key] = 0;\n        }\n      }\n\n      if (dirty) {\n        this.setState({\n          currentStyle,\n          currentVelocity,\n          lastIdealStyle,\n          lastIdealVelocity\n        });\n      }\n    };\n\n    this.startAnimationIfNecessary = () => {\n      if (this.unmounting || this.animationID != null) {\n        return;\n      } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n      // call cb? No, otherwise accidental parent rerender causes cb trigger\n\n\n      this.animationID = defaultRaf(timestamp => {\n        // https://github.com/chenglou/react-motion/pull/420\n        // > if execution passes the conditional if (this.unmounting), then\n        // executes async defaultRaf and after that component unmounts and after\n        // that the callback of defaultRaf is called, then setState will be called\n        // on unmounted component.\n        if (this.unmounting) {\n          return;\n        } // check if we need to animate in the first place\n\n\n        const propsStyle = this.props.style;\n\n        if (shouldStopAnimation(this.state.currentStyle, propsStyle, this.state.currentVelocity)) {\n          if (this.wasAnimating && this.props.onRest) {\n            this.props.onRest();\n          } // no need to cancel animationID here; shouldn't have any in flight\n\n\n          this.animationID = null;\n          this.wasAnimating = false;\n          this.accumulatedTime = 0;\n          return;\n        }\n\n        this.wasAnimating = true;\n        const currentTime = timestamp || defaultNow();\n        const timeDelta = currentTime - this.prevTime;\n        this.prevTime = currentTime;\n        this.accumulatedTime = this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart\n\n        if (this.accumulatedTime > msPerFrame * 10) {\n          this.accumulatedTime = 0;\n        }\n\n        if (this.accumulatedTime === 0) {\n          // no need to cancel animationID here; shouldn't have any in flight\n          this.animationID = null;\n          this.startAnimationIfNecessary();\n          return;\n        }\n\n        let currentFrameCompletion = (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n        const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n        let newLastIdealStyle = {};\n        let newLastIdealVelocity = {};\n        let newCurrentStyle = {};\n        let newCurrentVelocity = {};\n\n        for (let key in propsStyle) {\n          if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {\n            continue;\n          }\n\n          const styleValue = propsStyle[key];\n\n          if (typeof styleValue === 'number') {\n            newCurrentStyle[key] = styleValue;\n            newCurrentVelocity[key] = 0;\n            newLastIdealStyle[key] = styleValue;\n            newLastIdealVelocity[key] = 0;\n          } else {\n            let newLastIdealStyleValue = this.state.lastIdealStyle[key];\n            let newLastIdealVelocityValue = this.state.lastIdealVelocity[key];\n\n            for (let i = 0; i < framesToCatchUp; i++) {\n              [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n            }\n\n            const [nextIdealX, nextIdealV] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n            newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n            newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n            newLastIdealStyle[key] = newLastIdealStyleValue;\n            newLastIdealVelocity[key] = newLastIdealVelocityValue;\n          }\n        }\n\n        this.animationID = null; // the amount we're looped over above\n\n        this.accumulatedTime -= framesToCatchUp * msPerFrame;\n        this.setState({\n          currentStyle: newCurrentStyle,\n          currentVelocity: newCurrentVelocity,\n          lastIdealStyle: newLastIdealStyle,\n          lastIdealVelocity: newLastIdealVelocity\n        });\n        this.unreadPropStyle = null;\n        this.startAnimationIfNecessary();\n      });\n    };\n\n    this.state = this.defaultState();\n  }\n\n  defaultState() {\n    const {\n      defaultStyle,\n      style\n    } = this.props;\n    const currentStyle = defaultStyle || stripStyle(style);\n    const currentVelocity = mapToZero(currentStyle);\n    return {\n      currentStyle,\n      currentVelocity,\n      lastIdealStyle: currentStyle,\n      lastIdealVelocity: currentVelocity\n    };\n  } // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props) {\n    if (this.unreadPropStyle != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyle);\n    }\n\n    this.unreadPropStyle = props.style;\n\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render() {\n    const renderedChildren = this.props.children(this.state.currentStyle);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n\n}\nMotion.propTypes = {\n  // TOOD: warn against putting a config in here\n  defaultStyle: PropTypes.objectOf(PropTypes.number),\n  style: PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.object])).isRequired,\n  children: PropTypes.func.isRequired,\n  onRest: PropTypes.func\n};","map":{"version":3,"sources":["/Users/leshlyerivera/Documents/GitHub/portfolio/src/components/gallery/src/Motion.js"],"names":["mapToZero","stripStyle","stepper","defaultNow","defaultRaf","shouldStopAnimation","React","PropTypes","msPerFrame","Motion","Component","constructor","props","unmounting","wasAnimating","animationID","prevTime","accumulatedTime","unreadPropStyle","clearUnreadPropStyle","destStyle","dirty","currentStyle","currentVelocity","lastIdealStyle","lastIdealVelocity","state","key","Object","prototype","hasOwnProperty","call","styleValue","setState","startAnimationIfNecessary","timestamp","propsStyle","style","onRest","currentTime","timeDelta","currentFrameCompletion","Math","floor","framesToCatchUp","newLastIdealStyle","newLastIdealVelocity","newCurrentStyle","newCurrentVelocity","newLastIdealStyleValue","newLastIdealVelocityValue","i","val","stiffness","damping","precision","nextIdealX","nextIdealV","defaultState","defaultStyle","componentDidMount","UNSAFE_componentWillReceiveProps","componentWillUnmount","cancel","render","renderedChildren","children","Children","only","propTypes","objectOf","number","oneOfType","object","isRequired","func"],"mappings":"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","sourcesContent":["/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport type {\n  ReactElement,\n  PlainStyle,\n  Style,\n  Velocity,\n  MotionProps,\n} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\ntype MotionState = {\n  currentStyle: PlainStyle,\n  currentVelocity: Velocity,\n  lastIdealStyle: PlainStyle,\n  lastIdealVelocity: Velocity,\n};\n\nexport default class Motion extends React.Component<MotionProps, MotionState> {\n  static propTypes = {\n    // TOOD: warn against putting a config in here\n    defaultStyle: PropTypes.objectOf(PropTypes.number),\n    style: PropTypes.objectOf(\n      PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n    ).isRequired,\n    children: PropTypes.func.isRequired,\n    onRest: PropTypes.func,\n  };\n\n  constructor(props: MotionProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  unmounting: boolean = false;\n  wasAnimating: boolean = false;\n  animationID: ?number = null;\n  prevTime: number = 0;\n  accumulatedTime: number = 0;\n\n  defaultState(): MotionState {\n    const { defaultStyle, style } = this.props;\n    const currentStyle = defaultStyle || stripStyle(style);\n    const currentVelocity = mapToZero(currentStyle);\n    return {\n      currentStyle,\n      currentVelocity,\n      lastIdealStyle: currentStyle,\n      lastIdealVelocity: currentVelocity,\n    };\n  }\n\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyle: ?Style = null;\n  // after checking for unreadPropStyle != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (destStyle: Style): void => {\n    let dirty = false;\n    let {\n      currentStyle,\n      currentVelocity,\n      lastIdealStyle,\n      lastIdealVelocity,\n    } = this.state;\n\n    for (let key in destStyle) {\n      if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n        continue;\n      }\n\n      const styleValue = destStyle[key];\n      if (typeof styleValue === 'number') {\n        if (!dirty) {\n          dirty = true;\n          currentStyle = { ...currentStyle };\n          currentVelocity = { ...currentVelocity };\n          lastIdealStyle = { ...lastIdealStyle };\n          lastIdealVelocity = { ...lastIdealVelocity };\n        }\n\n        currentStyle[key] = styleValue;\n        currentVelocity[key] = 0;\n        lastIdealStyle[key] = styleValue;\n        lastIdealVelocity[key] = 0;\n      }\n    }\n\n    if (dirty) {\n      this.setState({\n        currentStyle,\n        currentVelocity,\n        lastIdealStyle,\n        lastIdealVelocity,\n      });\n    }\n  };\n\n  startAnimationIfNecessary = (): void => {\n    if (this.unmounting || this.animationID != null) {\n      return;\n    }\n\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf(timestamp => {\n      // https://github.com/chenglou/react-motion/pull/420\n      // > if execution passes the conditional if (this.unmounting), then\n      // executes async defaultRaf and after that component unmounts and after\n      // that the callback of defaultRaf is called, then setState will be called\n      // on unmounted component.\n      if (this.unmounting) {\n        return;\n      }\n\n      // check if we need to animate in the first place\n      const propsStyle: Style = this.props.style;\n      if (\n        shouldStopAnimation(\n          this.state.currentStyle,\n          propsStyle,\n          this.state.currentVelocity,\n        )\n      ) {\n        if (this.wasAnimating && this.props.onRest) {\n          this.props.onRest();\n        }\n\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.wasAnimating = false;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      this.wasAnimating = true;\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime -\n          Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) /\n        msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let newLastIdealStyle: PlainStyle = {};\n      let newLastIdealVelocity: Velocity = {};\n      let newCurrentStyle: PlainStyle = {};\n      let newCurrentVelocity: Velocity = {};\n\n      for (let key in propsStyle) {\n        if (!Object.prototype.hasOwnProperty.call(propsStyle, key)) {\n          continue;\n        }\n\n        const styleValue = propsStyle[key];\n        if (typeof styleValue === 'number') {\n          newCurrentStyle[key] = styleValue;\n          newCurrentVelocity[key] = 0;\n          newLastIdealStyle[key] = styleValue;\n          newLastIdealVelocity[key] = 0;\n        } else {\n          let newLastIdealStyleValue = this.state.lastIdealStyle[key];\n          let newLastIdealVelocityValue = this.state.lastIdealVelocity[key];\n          for (let i = 0; i < framesToCatchUp; i++) {\n            [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n          }\n          const [nextIdealX, nextIdealV] = stepper(\n            msPerFrame / 1000,\n            newLastIdealStyleValue,\n            newLastIdealVelocityValue,\n            styleValue.val,\n            styleValue.stiffness,\n            styleValue.damping,\n            styleValue.precision,\n          );\n\n          newCurrentStyle[key] =\n            newLastIdealStyleValue +\n            (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n          newCurrentVelocity[key] =\n            newLastIdealVelocityValue +\n            (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n          newLastIdealStyle[key] = newLastIdealStyleValue;\n          newLastIdealVelocity[key] = newLastIdealVelocityValue;\n        }\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyle: newCurrentStyle,\n        currentVelocity: newCurrentVelocity,\n        lastIdealStyle: newLastIdealStyle,\n        lastIdealVelocity: newLastIdealVelocity,\n      });\n\n      this.unreadPropStyle = null;\n\n      this.startAnimationIfNecessary();\n    });\n  };\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props: MotionProps) {\n    if (this.unreadPropStyle != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyle);\n    }\n\n    this.unreadPropStyle = props.style;\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    const renderedChildren = this.props.children(this.state.currentStyle);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}