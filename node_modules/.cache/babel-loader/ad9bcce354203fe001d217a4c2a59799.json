{"ast":null,"code":"// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n// array reference around.\nlet reusedTuple = [0, 0];\nexport default function stepper(secondPerFrame, x, v, destX, k, b, precision) {\n  // Spring stiffness, in kg / s^2\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  const Fspring = -k * (x - destX); // Damping, in kg / s\n\n  const Fdamper = -b * v; // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n\n  const a = Fspring + Fdamper;\n  const newV = v + a * secondPerFrame;\n  const newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}","map":{"version":3,"sources":["/Users/leshlyerivera/Documents/GitHub/portfolio/src/components/gallery/src/stepper.js"],"names":["reusedTuple","stepper","secondPerFrame","x","v","destX","k","b","precision","Fspring","Fdamper","a","newV","newX","Math","abs"],"mappings":"AAEA;AACA;AACA;AACA;AACA,IAAIA,WAA6B,GAAG,CAAC,CAAD,EAAI,CAAJ,CAApC;AACA,eAAe,SAASC,OAAT,CACbC,cADa,EAEbC,CAFa,EAGbC,CAHa,EAIbC,KAJa,EAKbC,CALa,EAMbC,CANa,EAObC,SAPa,EAQK;AAClB;AAEA;AACA;AACA,QAAMC,OAAO,GAAG,CAACH,CAAD,IAAMH,CAAC,GAAGE,KAAV,CAAhB,CALkB,CAOlB;;AACA,QAAMK,OAAO,GAAG,CAACH,CAAD,GAAKH,CAArB,CARkB,CAUlB;AACA;AACA;;AACA,QAAMO,CAAC,GAAGF,OAAO,GAAGC,OAApB;AAEA,QAAME,IAAI,GAAGR,CAAC,GAAGO,CAAC,GAAGT,cAArB;AACA,QAAMW,IAAI,GAAGV,CAAC,GAAGS,IAAI,GAAGV,cAAxB;;AAEA,MAAIY,IAAI,CAACC,GAAL,CAASH,IAAT,IAAiBJ,SAAjB,IAA8BM,IAAI,CAACC,GAAL,CAASF,IAAI,GAAGR,KAAhB,IAAyBG,SAA3D,EAAsE;AACpER,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBK,KAAjB;AACAL,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAAjB;AACA,WAAOA,WAAP;AACD;;AAEDA,EAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBa,IAAjB;AACAb,EAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBY,IAAjB;AACA,SAAOZ,WAAP;AACD","sourcesContent":["/* @flow */\n\n// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n// array reference around.\nlet reusedTuple: [number, number] = [0, 0];\nexport default function stepper(\n  secondPerFrame: number,\n  x: number,\n  v: number,\n  destX: number,\n  k: number,\n  b: number,\n  precision: number,\n): [number, number] {\n  // Spring stiffness, in kg / s^2\n\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  const Fspring = -k * (x - destX);\n\n  // Damping, in kg / s\n  const Fdamper = -b * v;\n\n  // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n  const a = Fspring + Fdamper;\n\n  const newV = v + a * secondPerFrame;\n  const newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}\n"]},"metadata":{},"sourceType":"module"}