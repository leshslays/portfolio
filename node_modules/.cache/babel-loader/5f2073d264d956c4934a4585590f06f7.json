{"ast":null,"code":"import mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nconst msPerFrame = 1000 / 60;\n\nfunction shouldStopAnimationAll(currentStyles, styles, currentVelocities) {\n  for (let i = 0; i < currentStyles.length; i++) {\n    if (!shouldStopAnimation(currentStyles[i], styles[i], currentVelocities[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport default class StaggeredMotion extends React.Component {\n  constructor(props) {\n    super(props);\n    this.unmounting = false;\n    this.animationID = null;\n    this.prevTime = 0;\n    this.accumulatedTime = 0;\n    this.unreadPropStyles = null;\n\n    this.clearUnreadPropStyle = unreadPropStyles => {\n      let {\n        currentStyles,\n        currentVelocities,\n        lastIdealStyles,\n        lastIdealVelocities\n      } = this.state;\n      let someDirty = false;\n\n      for (let i = 0; i < unreadPropStyles.length; i++) {\n        const unreadPropStyle = unreadPropStyles[i];\n        let dirty = false;\n\n        for (let key in unreadPropStyle) {\n          if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n            continue;\n          }\n\n          const styleValue = unreadPropStyle[key];\n\n          if (typeof styleValue === 'number') {\n            if (!dirty) {\n              dirty = true;\n              someDirty = true;\n              currentStyles[i] = { ...currentStyles[i]\n              };\n              currentVelocities[i] = { ...currentVelocities[i]\n              };\n              lastIdealStyles[i] = { ...lastIdealStyles[i]\n              };\n              lastIdealVelocities[i] = { ...lastIdealVelocities[i]\n              };\n            }\n\n            currentStyles[i][key] = styleValue;\n            currentVelocities[i][key] = 0;\n            lastIdealStyles[i][key] = styleValue;\n            lastIdealVelocities[i][key] = 0;\n          }\n        }\n      }\n\n      if (someDirty) {\n        this.setState({\n          currentStyles,\n          currentVelocities,\n          lastIdealStyles,\n          lastIdealVelocities\n        });\n      }\n    };\n\n    this.startAnimationIfNecessary = () => {\n      if (this.unmounting || this.animationID != null) {\n        return;\n      } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n      // call cb? No, otherwise accidental parent rerender causes cb trigger\n\n\n      this.animationID = defaultRaf(timestamp => {\n        // https://github.com/chenglou/react-motion/pull/420\n        // > if execution passes the conditional if (this.unmounting), then\n        // executes async defaultRaf and after that component unmounts and after\n        // that the callback of defaultRaf is called, then setState will be called\n        // on unmounted component.\n        if (this.unmounting) {\n          return;\n        }\n\n        const destStyles = this.props.styles(this.state.lastIdealStyles); // check if we need to animate in the first place\n\n        if (shouldStopAnimationAll(this.state.currentStyles, destStyles, this.state.currentVelocities)) {\n          // no need to cancel animationID here; shouldn't have any in flight\n          this.animationID = null;\n          this.accumulatedTime = 0;\n          return;\n        }\n\n        const currentTime = timestamp || defaultNow();\n        const timeDelta = currentTime - this.prevTime;\n        this.prevTime = currentTime;\n        this.accumulatedTime = this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart\n\n        if (this.accumulatedTime > msPerFrame * 10) {\n          this.accumulatedTime = 0;\n        }\n\n        if (this.accumulatedTime === 0) {\n          // no need to cancel animationID here; shouldn't have any in flight\n          this.animationID = null;\n          this.startAnimationIfNecessary();\n          return;\n        }\n\n        let currentFrameCompletion = (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n        const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n        let newLastIdealStyles = [];\n        let newLastIdealVelocities = [];\n        let newCurrentStyles = [];\n        let newCurrentVelocities = [];\n\n        for (let i = 0; i < destStyles.length; i++) {\n          const destStyle = destStyles[i];\n          let newCurrentStyle = {};\n          let newCurrentVelocity = {};\n          let newLastIdealStyle = {};\n          let newLastIdealVelocity = {};\n\n          for (let key in destStyle) {\n            if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n              continue;\n            }\n\n            const styleValue = destStyle[key];\n\n            if (typeof styleValue === 'number') {\n              newCurrentStyle[key] = styleValue;\n              newCurrentVelocity[key] = 0;\n              newLastIdealStyle[key] = styleValue;\n              newLastIdealVelocity[key] = 0;\n            } else {\n              let newLastIdealStyleValue = this.state.lastIdealStyles[i][key];\n              let newLastIdealVelocityValue = this.state.lastIdealVelocities[i][key];\n\n              for (let j = 0; j < framesToCatchUp; j++) {\n                [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n              }\n\n              const [nextIdealX, nextIdealV] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n              newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n              newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n              newLastIdealStyle[key] = newLastIdealStyleValue;\n              newLastIdealVelocity[key] = newLastIdealVelocityValue;\n            }\n          }\n\n          newCurrentStyles[i] = newCurrentStyle;\n          newCurrentVelocities[i] = newCurrentVelocity;\n          newLastIdealStyles[i] = newLastIdealStyle;\n          newLastIdealVelocities[i] = newLastIdealVelocity;\n        }\n\n        this.animationID = null; // the amount we're looped over above\n\n        this.accumulatedTime -= framesToCatchUp * msPerFrame;\n        this.setState({\n          currentStyles: newCurrentStyles,\n          currentVelocities: newCurrentVelocities,\n          lastIdealStyles: newLastIdealStyles,\n          lastIdealVelocities: newLastIdealVelocities\n        });\n        this.unreadPropStyles = null;\n        this.startAnimationIfNecessary();\n      });\n    };\n\n    this.state = this.defaultState();\n  }\n\n  defaultState() {\n    const {\n      defaultStyles,\n      styles\n    } = this.props;\n    const currentStyles = defaultStyles || styles().map(stripStyle);\n    const currentVelocities = currentStyles.map(currentStyle => mapToZero(currentStyle));\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles: currentStyles,\n      lastIdealVelocities: currentVelocities\n    };\n  }\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props) {\n    if (this.unreadPropStyles != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    this.unreadPropStyles = props.styles(this.state.lastIdealStyles);\n\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render() {\n    const renderedChildren = this.props.children(this.state.currentStyles);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n\n}\nStaggeredMotion.propTypes = {\n  // TOOD: warn against putting a config in here\n  defaultStyles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n  styles: PropTypes.func.isRequired,\n  children: PropTypes.func.isRequired\n};","map":{"version":3,"sources":["/Users/leshlyerivera/Documents/GitHub/portfolio/src/components/gallery/src/StaggeredMotion.js"],"names":["mapToZero","stripStyle","stepper","defaultNow","defaultRaf","shouldStopAnimation","React","PropTypes","msPerFrame","shouldStopAnimationAll","currentStyles","styles","currentVelocities","i","length","StaggeredMotion","Component","constructor","props","unmounting","animationID","prevTime","accumulatedTime","unreadPropStyles","clearUnreadPropStyle","lastIdealStyles","lastIdealVelocities","state","someDirty","unreadPropStyle","dirty","key","Object","prototype","hasOwnProperty","call","styleValue","setState","startAnimationIfNecessary","timestamp","destStyles","currentTime","timeDelta","currentFrameCompletion","Math","floor","framesToCatchUp","newLastIdealStyles","newLastIdealVelocities","newCurrentStyles","newCurrentVelocities","destStyle","newCurrentStyle","newCurrentVelocity","newLastIdealStyle","newLastIdealVelocity","newLastIdealStyleValue","newLastIdealVelocityValue","j","val","stiffness","damping","precision","nextIdealX","nextIdealV","defaultState","defaultStyles","map","currentStyle","componentDidMount","UNSAFE_componentWillReceiveProps","componentWillUnmount","cancel","render","renderedChildren","children","Children","only","propTypes","arrayOf","objectOf","number","func","isRequired"],"mappings":"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","sourcesContent":["/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport type {\n  ReactElement,\n  PlainStyle,\n  Style,\n  Velocity,\n  StaggeredProps,\n} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\ntype StaggeredMotionState = {\n  currentStyles: Array<PlainStyle>,\n  currentVelocities: Array<Velocity>,\n  lastIdealStyles: Array<PlainStyle>,\n  lastIdealVelocities: Array<Velocity>,\n};\n\nfunction shouldStopAnimationAll(\n  currentStyles: Array<PlainStyle>,\n  styles: Array<Style>,\n  currentVelocities: Array<Velocity>,\n): boolean {\n  for (let i = 0; i < currentStyles.length; i++) {\n    if (\n      !shouldStopAnimation(currentStyles[i], styles[i], currentVelocities[i])\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport default class StaggeredMotion extends React.Component<\n  StaggeredProps,\n  StaggeredMotionState,\n> {\n  static propTypes = {\n    // TOOD: warn against putting a config in here\n    defaultStyles: PropTypes.arrayOf(PropTypes.objectOf(PropTypes.number)),\n    styles: PropTypes.func.isRequired,\n    children: PropTypes.func.isRequired,\n  };\n\n  constructor(props: StaggeredProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  defaultState(): StaggeredMotionState {\n    const { defaultStyles, styles } = this.props;\n    const currentStyles: Array<PlainStyle> =\n      defaultStyles || styles().map(stripStyle);\n    const currentVelocities = currentStyles.map(currentStyle =>\n      mapToZero(currentStyle),\n    );\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles: currentStyles,\n      lastIdealVelocities: currentVelocities,\n    };\n  }\n\n  unmounting: boolean = false;\n  animationID: ?number = null;\n  prevTime = 0;\n  accumulatedTime = 0;\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyles: ?Array<Style> = null;\n\n  // after checking for unreadPropStyles != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (unreadPropStyles: Array<Style>): void => {\n    let {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n    } = this.state;\n\n    let someDirty = false;\n    for (let i = 0; i < unreadPropStyles.length; i++) {\n      const unreadPropStyle = unreadPropStyles[i];\n      let dirty = false;\n\n      for (let key in unreadPropStyle) {\n        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n          continue;\n        }\n\n        const styleValue = unreadPropStyle[key];\n        if (typeof styleValue === 'number') {\n          if (!dirty) {\n            dirty = true;\n            someDirty = true;\n            currentStyles[i] = { ...currentStyles[i] };\n            currentVelocities[i] = { ...currentVelocities[i] };\n            lastIdealStyles[i] = { ...lastIdealStyles[i] };\n            lastIdealVelocities[i] = { ...lastIdealVelocities[i] };\n          }\n          currentStyles[i][key] = styleValue;\n          currentVelocities[i][key] = 0;\n          lastIdealStyles[i][key] = styleValue;\n          lastIdealVelocities[i][key] = 0;\n        }\n      }\n    }\n\n    if (someDirty) {\n      this.setState({\n        currentStyles,\n        currentVelocities,\n        lastIdealStyles,\n        lastIdealVelocities,\n      });\n    }\n  };\n\n  startAnimationIfNecessary = (): void => {\n    if (this.unmounting || this.animationID != null) {\n      return;\n    }\n\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf(timestamp => {\n      // https://github.com/chenglou/react-motion/pull/420\n      // > if execution passes the conditional if (this.unmounting), then\n      // executes async defaultRaf and after that component unmounts and after\n      // that the callback of defaultRaf is called, then setState will be called\n      // on unmounted component.\n      if (this.unmounting) {\n        return;\n      }\n\n      const destStyles: Array<Style> = this.props.styles(\n        this.state.lastIdealStyles,\n      );\n\n      // check if we need to animate in the first place\n      if (\n        shouldStopAnimationAll(\n          this.state.currentStyles,\n          destStyles,\n          this.state.currentVelocities,\n        )\n      ) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime -\n          Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) /\n        msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let newLastIdealStyles = [];\n      let newLastIdealVelocities = [];\n      let newCurrentStyles = [];\n      let newCurrentVelocities = [];\n\n      for (let i = 0; i < destStyles.length; i++) {\n        const destStyle = destStyles[i];\n        let newCurrentStyle: PlainStyle = {};\n        let newCurrentVelocity: Velocity = {};\n        let newLastIdealStyle: PlainStyle = {};\n        let newLastIdealVelocity: Velocity = {};\n\n        for (let key in destStyle) {\n          if (!Object.prototype.hasOwnProperty.call(destStyle, key)) {\n            continue;\n          }\n\n          const styleValue = destStyle[key];\n          if (typeof styleValue === 'number') {\n            newCurrentStyle[key] = styleValue;\n            newCurrentVelocity[key] = 0;\n            newLastIdealStyle[key] = styleValue;\n            newLastIdealVelocity[key] = 0;\n          } else {\n            let newLastIdealStyleValue = this.state.lastIdealStyles[i][key];\n            let newLastIdealVelocityValue = this.state.lastIdealVelocities[i][\n              key\n            ];\n            for (let j = 0; j < framesToCatchUp; j++) {\n              [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n                msPerFrame / 1000,\n                newLastIdealStyleValue,\n                newLastIdealVelocityValue,\n                styleValue.val,\n                styleValue.stiffness,\n                styleValue.damping,\n                styleValue.precision,\n              );\n            }\n            const [nextIdealX, nextIdealV] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n\n            newCurrentStyle[key] =\n              newLastIdealStyleValue +\n              (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n            newCurrentVelocity[key] =\n              newLastIdealVelocityValue +\n              (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n            newLastIdealStyle[key] = newLastIdealStyleValue;\n            newLastIdealVelocity[key] = newLastIdealVelocityValue;\n          }\n        }\n\n        newCurrentStyles[i] = newCurrentStyle;\n        newCurrentVelocities[i] = newCurrentVelocity;\n        newLastIdealStyles[i] = newLastIdealStyle;\n        newLastIdealVelocities[i] = newLastIdealVelocity;\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyles: newCurrentStyles,\n        currentVelocities: newCurrentVelocities,\n        lastIdealStyles: newLastIdealStyles,\n        lastIdealVelocities: newLastIdealVelocities,\n      });\n\n      this.unreadPropStyles = null;\n\n      this.startAnimationIfNecessary();\n    });\n  };\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props: StaggeredProps) {\n    if (this.unreadPropStyles != null) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    this.unreadPropStyles = props.styles(this.state.lastIdealStyles);\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    const renderedChildren = this.props.children(this.state.currentStyles);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}