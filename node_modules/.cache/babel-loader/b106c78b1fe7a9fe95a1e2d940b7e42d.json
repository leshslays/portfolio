{"ast":null,"code":"import mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport mergeDiff from './mergeDiff';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nconst msPerFrame = 1000 / 60; // the children function & (potential) styles function asks as param an\n// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format\n// {key: string, data?: any, style: PlainStyle}. However, the way we keep\n// internal states doesn't contain such a data structure (check the state and\n// TransitionMotionState). So when children function and others ask for such\n// data we need to generate them on the fly by combining mergedPropsStyles and\n// currentStyles/lastIdealStyles\n\nfunction rehydrateStyles(mergedPropsStyles, unreadPropStyles, plainStyles) {\n  // Copy the value to a `const` so that Flow understands that the const won't\n  // change and will be non-nullable in the callback below.\n  const cUnreadPropStyles = unreadPropStyles;\n\n  if (cUnreadPropStyles == null) {\n    return mergedPropsStyles.map((mergedPropsStyle, i) => ({\n      key: mergedPropsStyle.key,\n      data: mergedPropsStyle.data,\n      style: plainStyles[i]\n    }));\n  }\n\n  return mergedPropsStyles.map((mergedPropsStyle, i) => {\n    for (let j = 0; j < cUnreadPropStyles.length; j++) {\n      if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {\n        return {\n          key: cUnreadPropStyles[j].key,\n          data: cUnreadPropStyles[j].data,\n          style: plainStyles[i]\n        };\n      }\n    }\n\n    return {\n      key: mergedPropsStyle.key,\n      data: mergedPropsStyle.data,\n      style: plainStyles[i]\n    };\n  });\n}\n\nfunction shouldStopAnimationAll(currentStyles, destStyles, currentVelocities, mergedPropsStyles) {\n  if (mergedPropsStyles.length !== destStyles.length) {\n    return false;\n  }\n\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (mergedPropsStyles[i].key !== destStyles[i].key) {\n      return false;\n    }\n  } // we have the invariant that mergedPropsStyles and\n  // currentStyles/currentVelocities/last* are synced in terms of cells, see\n  // mergeAndSync comment for more info\n\n\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (!shouldStopAnimation(currentStyles[i], destStyles[i].style, currentVelocities[i])) {\n      return false;\n    }\n  }\n\n  return true;\n} // core key merging logic\n// things to do: say previously merged style is {a, b}, dest style (prop) is {b,\n// c}, previous current (interpolating) style is {a, b}\n// **invariant**: current[i] corresponds to merged[i] in terms of key\n// steps:\n// turn merged style into {a?, b, c}\n//    add c, value of c is destStyles.c\n//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}\n// turn current (interpolating) style from {a, b} into {a?, b, c}\n//    maybe remove a\n//    certainly add c, value of c is willEnter(c)\n// loop over merged and construct new current\n// dest doesn't change, that's owner's\n\n\nfunction mergeAndSync(willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldLastIdealStyles, oldLastIdealVelocities) {\n  const newMergedPropsStyles = mergeDiff(oldMergedPropsStyles, destStyles, (oldIndex, oldMergedPropsStyle) => {\n    const leavingStyle = willLeave(oldMergedPropsStyle);\n\n    if (leavingStyle == null) {\n      didLeave({\n        key: oldMergedPropsStyle.key,\n        data: oldMergedPropsStyle.data\n      });\n      return null;\n    }\n\n    if (shouldStopAnimation(oldCurrentStyles[oldIndex], leavingStyle, oldCurrentVelocities[oldIndex])) {\n      didLeave({\n        key: oldMergedPropsStyle.key,\n        data: oldMergedPropsStyle.data\n      });\n      return null;\n    }\n\n    return {\n      key: oldMergedPropsStyle.key,\n      data: oldMergedPropsStyle.data,\n      style: leavingStyle\n    };\n  });\n  let newCurrentStyles = [];\n  let newCurrentVelocities = [];\n  let newLastIdealStyles = [];\n  let newLastIdealVelocities = [];\n\n  for (let i = 0; i < newMergedPropsStyles.length; i++) {\n    const newMergedPropsStyleCell = newMergedPropsStyles[i];\n    let foundOldIndex = null;\n\n    for (let j = 0; j < oldMergedPropsStyles.length; j++) {\n      if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {\n        foundOldIndex = j;\n        break;\n      }\n    } // TODO: key search code\n\n\n    if (foundOldIndex == null) {\n      const plainStyle = willEnter(newMergedPropsStyleCell);\n      newCurrentStyles[i] = plainStyle;\n      newLastIdealStyles[i] = plainStyle;\n      const velocity = mapToZero(newMergedPropsStyleCell.style);\n      newCurrentVelocities[i] = velocity;\n      newLastIdealVelocities[i] = velocity;\n    } else {\n      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];\n      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];\n      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];\n      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];\n    }\n  }\n\n  return [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities];\n}\n\nexport default class TransitionMotion extends React.Component {\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  constructor(props) {\n    super(props);\n    this.unmounting = false;\n    this.animationID = null;\n    this.prevTime = 0;\n    this.accumulatedTime = 0;\n    this.unreadPropStyles = null;\n\n    this.clearUnreadPropStyle = unreadPropStyles => {\n      let [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync(this.props.willEnter, this.props.willLeave, this.props.didLeave, this.state.mergedPropsStyles, unreadPropStyles, this.state.currentStyles, this.state.currentVelocities, this.state.lastIdealStyles, this.state.lastIdealVelocities);\n\n      for (let i = 0; i < unreadPropStyles.length; i++) {\n        const unreadPropStyle = unreadPropStyles[i].style;\n        let dirty = false;\n\n        for (let key in unreadPropStyle) {\n          if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n            continue;\n          }\n\n          const styleValue = unreadPropStyle[key];\n\n          if (typeof styleValue === 'number') {\n            if (!dirty) {\n              dirty = true;\n              currentStyles[i] = { ...currentStyles[i]\n              };\n              currentVelocities[i] = { ...currentVelocities[i]\n              };\n              lastIdealStyles[i] = { ...lastIdealStyles[i]\n              };\n              lastIdealVelocities[i] = { ...lastIdealVelocities[i]\n              };\n              mergedPropsStyles[i] = {\n                key: mergedPropsStyles[i].key,\n                data: mergedPropsStyles[i].data,\n                style: { ...mergedPropsStyles[i].style\n                }\n              };\n            }\n\n            currentStyles[i][key] = styleValue;\n            currentVelocities[i][key] = 0;\n            lastIdealStyles[i][key] = styleValue;\n            lastIdealVelocities[i][key] = 0;\n            mergedPropsStyles[i].style[key] = styleValue;\n          }\n        }\n      } // unlike the other 2 components, we can't detect staleness and optionally\n      // opt out of setState here. each style object's data might contain new\n      // stuff we're not/cannot compare\n\n\n      this.setState({\n        currentStyles,\n        currentVelocities,\n        mergedPropsStyles,\n        lastIdealStyles,\n        lastIdealVelocities\n      });\n    };\n\n    this.startAnimationIfNecessary = () => {\n      if (this.unmounting || this.animationID != null) {\n        return;\n      } // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n      // call cb? No, otherwise accidental parent rerender causes cb trigger\n\n\n      this.animationID = defaultRaf(timestamp => {\n        // https://github.com/chenglou/react-motion/pull/420\n        // > if execution passes the conditional if (this.unmounting), then\n        // executes async defaultRaf and after that component unmounts and after\n        // that the callback of defaultRaf is called, then setState will be called\n        // on unmounted component.\n        if (this.unmounting) {\n          return;\n        }\n\n        const propStyles = this.props.styles;\n        let destStyles = typeof propStyles === 'function' ? propStyles(rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.lastIdealStyles)) : propStyles; // check if we need to animate in the first place\n\n        if (shouldStopAnimationAll(this.state.currentStyles, destStyles, this.state.currentVelocities, this.state.mergedPropsStyles)) {\n          // no need to cancel animationID here; shouldn't have any in flight\n          this.animationID = null;\n          this.accumulatedTime = 0;\n          return;\n        }\n\n        const currentTime = timestamp || defaultNow();\n        const timeDelta = currentTime - this.prevTime;\n        this.prevTime = currentTime;\n        this.accumulatedTime = this.accumulatedTime + timeDelta; // more than 10 frames? prolly switched browser tab. Restart\n\n        if (this.accumulatedTime > msPerFrame * 10) {\n          this.accumulatedTime = 0;\n        }\n\n        if (this.accumulatedTime === 0) {\n          // no need to cancel animationID here; shouldn't have any in flight\n          this.animationID = null;\n          this.startAnimationIfNecessary();\n          return;\n        }\n\n        let currentFrameCompletion = (this.accumulatedTime - Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) / msPerFrame;\n        const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n        let [newMergedPropsStyles, newCurrentStyles, newCurrentVelocities, newLastIdealStyles, newLastIdealVelocities] = mergeAndSync(this.props.willEnter, this.props.willLeave, this.props.didLeave, this.state.mergedPropsStyles, destStyles, this.state.currentStyles, this.state.currentVelocities, this.state.lastIdealStyles, this.state.lastIdealVelocities);\n\n        for (let i = 0; i < newMergedPropsStyles.length; i++) {\n          const newMergedPropsStyle = newMergedPropsStyles[i].style;\n          let newCurrentStyle = {};\n          let newCurrentVelocity = {};\n          let newLastIdealStyle = {};\n          let newLastIdealVelocity = {};\n\n          for (let key in newMergedPropsStyle) {\n            if (!Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)) {\n              continue;\n            }\n\n            const styleValue = newMergedPropsStyle[key];\n\n            if (typeof styleValue === 'number') {\n              newCurrentStyle[key] = styleValue;\n              newCurrentVelocity[key] = 0;\n              newLastIdealStyle[key] = styleValue;\n              newLastIdealVelocity[key] = 0;\n            } else {\n              let newLastIdealStyleValue = newLastIdealStyles[i][key];\n              let newLastIdealVelocityValue = newLastIdealVelocities[i][key];\n\n              for (let j = 0; j < framesToCatchUp; j++) {\n                [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n              }\n\n              const [nextIdealX, nextIdealV] = stepper(msPerFrame / 1000, newLastIdealStyleValue, newLastIdealVelocityValue, styleValue.val, styleValue.stiffness, styleValue.damping, styleValue.precision);\n              newCurrentStyle[key] = newLastIdealStyleValue + (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n              newCurrentVelocity[key] = newLastIdealVelocityValue + (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n              newLastIdealStyle[key] = newLastIdealStyleValue;\n              newLastIdealVelocity[key] = newLastIdealVelocityValue;\n            }\n          }\n\n          newLastIdealStyles[i] = newLastIdealStyle;\n          newLastIdealVelocities[i] = newLastIdealVelocity;\n          newCurrentStyles[i] = newCurrentStyle;\n          newCurrentVelocities[i] = newCurrentVelocity;\n        }\n\n        this.animationID = null; // the amount we're looped over above\n\n        this.accumulatedTime -= framesToCatchUp * msPerFrame;\n        this.setState({\n          currentStyles: newCurrentStyles,\n          currentVelocities: newCurrentVelocities,\n          lastIdealStyles: newLastIdealStyles,\n          lastIdealVelocities: newLastIdealVelocities,\n          mergedPropsStyles: newMergedPropsStyles\n        });\n        this.unreadPropStyles = null;\n        this.startAnimationIfNecessary();\n      });\n    };\n\n    this.state = this.defaultState();\n  }\n\n  defaultState() {\n    const {\n      defaultStyles,\n      styles,\n      willEnter,\n      willLeave,\n      didLeave\n    } = this.props;\n    const destStyles = typeof styles === 'function' ? styles(defaultStyles) : styles; // this is special. for the first time around, we don't have a comparison\n    // between last (no last) and current merged props. we'll compute last so:\n    // say default is {a, b} and styles (dest style) is {b, c}, we'll\n    // fabricate last as {a, b}\n\n    let oldMergedPropsStyles;\n\n    if (defaultStyles == null) {\n      oldMergedPropsStyles = destStyles;\n    } else {\n      oldMergedPropsStyles = defaultStyles.map(defaultStyleCell => {\n        // TODO: key search code\n        for (let i = 0; i < destStyles.length; i++) {\n          if (destStyles[i].key === defaultStyleCell.key) {\n            return destStyles[i];\n          }\n        }\n\n        return defaultStyleCell;\n      });\n    }\n\n    const oldCurrentStyles = defaultStyles == null ? destStyles.map(s => stripStyle(s.style)) : defaultStyles.map(s => stripStyle(s.style));\n    const oldCurrentVelocities = defaultStyles == null ? destStyles.map(s => mapToZero(s.style)) : defaultStyles.map(s => mapToZero(s.style));\n    const [mergedPropsStyles, currentStyles, currentVelocities, lastIdealStyles, lastIdealVelocities] = mergeAndSync( // Because this is an old-style createReactClass component, Flow doesn't\n    // understand that the willEnter and willLeave props have default values\n    // and will always be present.\n    willEnter, willLeave, didLeave, oldMergedPropsStyles, destStyles, oldCurrentStyles, oldCurrentVelocities, oldCurrentStyles, // oldLastIdealStyles really\n    oldCurrentVelocities // oldLastIdealVelocities really\n    );\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n      mergedPropsStyles\n    };\n  } // after checking for unreadPropStyles != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props) {\n    if (this.unreadPropStyles) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    const styles = props.styles;\n\n    if (typeof styles === 'function') {\n      this.unreadPropStyles = styles(rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.lastIdealStyles));\n    } else {\n      this.unreadPropStyles = styles;\n    }\n\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render() {\n    const hydratedStyles = rehydrateStyles(this.state.mergedPropsStyles, this.unreadPropStyles, this.state.currentStyles);\n    const renderedChildren = this.props.children(hydratedStyles);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n\n}\nTransitionMotion.propTypes = {\n  defaultStyles: PropTypes.arrayOf(PropTypes.shape({\n    key: PropTypes.string.isRequired,\n    data: PropTypes.any,\n    style: PropTypes.objectOf(PropTypes.number).isRequired\n  })),\n  styles: PropTypes.oneOfType([PropTypes.func, PropTypes.arrayOf(PropTypes.shape({\n    key: PropTypes.string.isRequired,\n    data: PropTypes.any,\n    style: PropTypes.objectOf(PropTypes.oneOfType([PropTypes.number, PropTypes.object])).isRequired\n  }))]).isRequired,\n  children: PropTypes.func.isRequired,\n  willEnter: PropTypes.func,\n  willLeave: PropTypes.func,\n  didLeave: PropTypes.func\n};\nTransitionMotion.defaultProps = {\n  willEnter: styleThatEntered => stripStyle(styleThatEntered.style),\n  // recall: returning null makes the current unmounting TransitionStyle\n  // disappear immediately\n  willLeave: () => null,\n  didLeave: () => {}\n};","map":{"version":3,"sources":["/Users/leshlyerivera/Documents/GitHub/portfolio/src/components/gallery/src/TransitionMotion.js"],"names":["mapToZero","stripStyle","stepper","mergeDiff","defaultNow","defaultRaf","shouldStopAnimation","React","PropTypes","msPerFrame","rehydrateStyles","mergedPropsStyles","unreadPropStyles","plainStyles","cUnreadPropStyles","map","mergedPropsStyle","i","key","data","style","j","length","shouldStopAnimationAll","currentStyles","destStyles","currentVelocities","mergeAndSync","willEnter","willLeave","didLeave","oldMergedPropsStyles","oldCurrentStyles","oldCurrentVelocities","oldLastIdealStyles","oldLastIdealVelocities","newMergedPropsStyles","oldIndex","oldMergedPropsStyle","leavingStyle","newCurrentStyles","newCurrentVelocities","newLastIdealStyles","newLastIdealVelocities","newMergedPropsStyleCell","foundOldIndex","plainStyle","velocity","TransitionMotion","Component","constructor","props","unmounting","animationID","prevTime","accumulatedTime","clearUnreadPropStyle","lastIdealStyles","lastIdealVelocities","state","unreadPropStyle","dirty","Object","prototype","hasOwnProperty","call","styleValue","setState","startAnimationIfNecessary","timestamp","propStyles","styles","currentTime","timeDelta","currentFrameCompletion","Math","floor","framesToCatchUp","newMergedPropsStyle","newCurrentStyle","newCurrentVelocity","newLastIdealStyle","newLastIdealVelocity","newLastIdealStyleValue","newLastIdealVelocityValue","val","stiffness","damping","precision","nextIdealX","nextIdealV","defaultState","defaultStyles","defaultStyleCell","s","componentDidMount","UNSAFE_componentWillReceiveProps","componentWillUnmount","cancel","render","hydratedStyles","renderedChildren","children","Children","only","propTypes","arrayOf","shape","string","isRequired","any","objectOf","number","oneOfType","func","object","defaultProps","styleThatEntered"],"mappings":"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","sourcesContent":["/* @flow */\nimport mapToZero from './mapToZero';\nimport stripStyle from './stripStyle';\nimport stepper from './stepper';\nimport mergeDiff from './mergeDiff';\nimport defaultNow from 'performance-now';\nimport defaultRaf from 'raf';\nimport shouldStopAnimation from './shouldStopAnimation';\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nimport type {\n  ReactElement,\n  PlainStyle,\n  Velocity,\n  TransitionStyle,\n  TransitionPlainStyle,\n  WillEnter,\n  WillLeave,\n  DidLeave,\n  TransitionProps,\n} from './Types';\n\nconst msPerFrame = 1000 / 60;\n\n// the children function & (potential) styles function asks as param an\n// Array<TransitionPlainStyle>, where each TransitionPlainStyle is of the format\n// {key: string, data?: any, style: PlainStyle}. However, the way we keep\n// internal states doesn't contain such a data structure (check the state and\n// TransitionMotionState). So when children function and others ask for such\n// data we need to generate them on the fly by combining mergedPropsStyles and\n// currentStyles/lastIdealStyles\nfunction rehydrateStyles(\n  mergedPropsStyles: Array<TransitionStyle>,\n  unreadPropStyles: ?Array<TransitionStyle>,\n  plainStyles: Array<PlainStyle>,\n): Array<TransitionPlainStyle> {\n  // Copy the value to a `const` so that Flow understands that the const won't\n  // change and will be non-nullable in the callback below.\n  const cUnreadPropStyles = unreadPropStyles;\n  if (cUnreadPropStyles == null) {\n    return mergedPropsStyles.map((mergedPropsStyle, i) => ({\n      key: mergedPropsStyle.key,\n      data: mergedPropsStyle.data,\n      style: plainStyles[i],\n    }));\n  }\n  return mergedPropsStyles.map((mergedPropsStyle, i) => {\n    for (let j = 0; j < cUnreadPropStyles.length; j++) {\n      if (cUnreadPropStyles[j].key === mergedPropsStyle.key) {\n        return {\n          key: cUnreadPropStyles[j].key,\n          data: cUnreadPropStyles[j].data,\n          style: plainStyles[i],\n        };\n      }\n    }\n    return {\n      key: mergedPropsStyle.key,\n      data: mergedPropsStyle.data,\n      style: plainStyles[i],\n    };\n  });\n}\n\nfunction shouldStopAnimationAll(\n  currentStyles: Array<PlainStyle>,\n  destStyles: Array<TransitionStyle>,\n  currentVelocities: Array<Velocity>,\n  mergedPropsStyles: Array<TransitionStyle>,\n): boolean {\n  if (mergedPropsStyles.length !== destStyles.length) {\n    return false;\n  }\n\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (mergedPropsStyles[i].key !== destStyles[i].key) {\n      return false;\n    }\n  }\n\n  // we have the invariant that mergedPropsStyles and\n  // currentStyles/currentVelocities/last* are synced in terms of cells, see\n  // mergeAndSync comment for more info\n  for (let i = 0; i < mergedPropsStyles.length; i++) {\n    if (\n      !shouldStopAnimation(\n        currentStyles[i],\n        destStyles[i].style,\n        currentVelocities[i],\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// core key merging logic\n\n// things to do: say previously merged style is {a, b}, dest style (prop) is {b,\n// c}, previous current (interpolating) style is {a, b}\n// **invariant**: current[i] corresponds to merged[i] in terms of key\n\n// steps:\n// turn merged style into {a?, b, c}\n//    add c, value of c is destStyles.c\n//    maybe remove a, aka call willLeave(a), then merged is either {b, c} or {a, b, c}\n// turn current (interpolating) style from {a, b} into {a?, b, c}\n//    maybe remove a\n//    certainly add c, value of c is willEnter(c)\n// loop over merged and construct new current\n// dest doesn't change, that's owner's\nfunction mergeAndSync(\n  willEnter: WillEnter,\n  willLeave: WillLeave,\n  didLeave: DidLeave,\n  oldMergedPropsStyles: Array<TransitionStyle>,\n  destStyles: Array<TransitionStyle>,\n  oldCurrentStyles: Array<PlainStyle>,\n  oldCurrentVelocities: Array<Velocity>,\n  oldLastIdealStyles: Array<PlainStyle>,\n  oldLastIdealVelocities: Array<Velocity>,\n): [\n  Array<TransitionStyle>,\n  Array<PlainStyle>,\n  Array<Velocity>,\n  Array<PlainStyle>,\n  Array<Velocity>,\n] {\n  const newMergedPropsStyles = mergeDiff(\n    oldMergedPropsStyles,\n    destStyles,\n    (oldIndex, oldMergedPropsStyle) => {\n      const leavingStyle = willLeave(oldMergedPropsStyle);\n      if (leavingStyle == null) {\n        didLeave({\n          key: oldMergedPropsStyle.key,\n          data: oldMergedPropsStyle.data,\n        });\n        return null;\n      }\n      if (\n        shouldStopAnimation(\n          oldCurrentStyles[oldIndex],\n          leavingStyle,\n          oldCurrentVelocities[oldIndex],\n        )\n      ) {\n        didLeave({\n          key: oldMergedPropsStyle.key,\n          data: oldMergedPropsStyle.data,\n        });\n        return null;\n      }\n      return {\n        key: oldMergedPropsStyle.key,\n        data: oldMergedPropsStyle.data,\n        style: leavingStyle,\n      };\n    },\n  );\n\n  let newCurrentStyles = [];\n  let newCurrentVelocities = [];\n  let newLastIdealStyles = [];\n  let newLastIdealVelocities = [];\n  for (let i = 0; i < newMergedPropsStyles.length; i++) {\n    const newMergedPropsStyleCell = newMergedPropsStyles[i];\n    let foundOldIndex = null;\n    for (let j = 0; j < oldMergedPropsStyles.length; j++) {\n      if (oldMergedPropsStyles[j].key === newMergedPropsStyleCell.key) {\n        foundOldIndex = j;\n        break;\n      }\n    }\n    // TODO: key search code\n    if (foundOldIndex == null) {\n      const plainStyle = willEnter(newMergedPropsStyleCell);\n      newCurrentStyles[i] = plainStyle;\n      newLastIdealStyles[i] = plainStyle;\n\n      const velocity = mapToZero(newMergedPropsStyleCell.style);\n      newCurrentVelocities[i] = velocity;\n      newLastIdealVelocities[i] = velocity;\n    } else {\n      newCurrentStyles[i] = oldCurrentStyles[foundOldIndex];\n      newLastIdealStyles[i] = oldLastIdealStyles[foundOldIndex];\n      newCurrentVelocities[i] = oldCurrentVelocities[foundOldIndex];\n      newLastIdealVelocities[i] = oldLastIdealVelocities[foundOldIndex];\n    }\n  }\n\n  return [\n    newMergedPropsStyles,\n    newCurrentStyles,\n    newCurrentVelocities,\n    newLastIdealStyles,\n    newLastIdealVelocities,\n  ];\n}\n\ntype TransitionMotionDefaultProps = {\n  willEnter: WillEnter,\n  willLeave: WillLeave,\n  didLeave: DidLeave,\n};\n\ntype TransitionMotionState = {\n  // list of styles, each containing interpolating values. Part of what's passed\n  // to children function. Notice that this is\n  // Array<ActualInterpolatingStyleObject>, without the wrapper that is {key: ...,\n  // data: ... style: ActualInterpolatingStyleObject}. Only mergedPropsStyles\n  // contains the key & data info (so that we only have a single source of truth\n  // for these, and to save space). Check the comment for `rehydrateStyles` to\n  // see how we regenerate the entirety of what's passed to children function\n  currentStyles: Array<PlainStyle>,\n  currentVelocities: Array<Velocity>,\n  lastIdealStyles: Array<PlainStyle>,\n  lastIdealVelocities: Array<Velocity>,\n  // the array that keeps track of currently rendered stuff! Including stuff\n  // that you've unmounted but that's still animating. This is where it lives\n  mergedPropsStyles: Array<TransitionStyle>,\n};\n\nexport default class TransitionMotion extends React.Component<\n  TransitionProps,\n  TransitionMotionState,\n> {\n  static propTypes = {\n    defaultStyles: PropTypes.arrayOf(\n      PropTypes.shape({\n        key: PropTypes.string.isRequired,\n        data: PropTypes.any,\n        style: PropTypes.objectOf(PropTypes.number).isRequired,\n      }),\n    ),\n    styles: PropTypes.oneOfType([\n      PropTypes.func,\n      PropTypes.arrayOf(\n        PropTypes.shape({\n          key: PropTypes.string.isRequired,\n          data: PropTypes.any,\n          style: PropTypes.objectOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.object]),\n          ).isRequired,\n        }),\n      ),\n    ]).isRequired,\n    children: PropTypes.func.isRequired,\n    willEnter: PropTypes.func,\n    willLeave: PropTypes.func,\n    didLeave: PropTypes.func,\n  };\n\n  static defaultProps: TransitionMotionDefaultProps = {\n    willEnter: styleThatEntered => stripStyle(styleThatEntered.style),\n    // recall: returning null makes the current unmounting TransitionStyle\n    // disappear immediately\n    willLeave: () => null,\n    didLeave: () => {},\n  };\n\n  unmounting: boolean = false;\n  animationID: ?number = null;\n  prevTime = 0;\n  accumulatedTime = 0;\n  // it's possible that currentStyle's value is stale: if props is immediately\n  // changed from 0 to 400 to spring(0) again, the async currentStyle is still\n  // at 0 (didn't have time to tick and interpolate even once). If we naively\n  // compare currentStyle with destVal it'll be 0 === 0 (no animation, stop).\n  // In reality currentStyle should be 400\n  unreadPropStyles: ?Array<TransitionStyle> = null;\n\n  constructor(props: TransitionProps) {\n    super(props);\n    this.state = this.defaultState();\n  }\n\n  defaultState(): TransitionMotionState {\n    const {\n      defaultStyles,\n      styles,\n      willEnter,\n      willLeave,\n      didLeave,\n    } = this.props;\n    const destStyles: Array<TransitionStyle> =\n      typeof styles === 'function' ? styles(defaultStyles) : styles;\n\n    // this is special. for the first time around, we don't have a comparison\n    // between last (no last) and current merged props. we'll compute last so:\n    // say default is {a, b} and styles (dest style) is {b, c}, we'll\n    // fabricate last as {a, b}\n    let oldMergedPropsStyles: Array<TransitionStyle>;\n    if (defaultStyles == null) {\n      oldMergedPropsStyles = destStyles;\n    } else {\n      oldMergedPropsStyles = (defaultStyles: any).map(defaultStyleCell => {\n        // TODO: key search code\n        for (let i = 0; i < destStyles.length; i++) {\n          if (destStyles[i].key === defaultStyleCell.key) {\n            return destStyles[i];\n          }\n        }\n        return defaultStyleCell;\n      });\n    }\n    const oldCurrentStyles =\n      defaultStyles == null\n        ? destStyles.map(s => stripStyle(s.style))\n        : (defaultStyles: any).map(s => stripStyle(s.style));\n    const oldCurrentVelocities =\n      defaultStyles == null\n        ? destStyles.map(s => mapToZero(s.style))\n        : defaultStyles.map(s => mapToZero(s.style));\n    const [\n      mergedPropsStyles,\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n    ] = mergeAndSync(\n      // Because this is an old-style createReactClass component, Flow doesn't\n      // understand that the willEnter and willLeave props have default values\n      // and will always be present.\n      (willEnter: any),\n      (willLeave: any),\n      (didLeave: any),\n      oldMergedPropsStyles,\n      destStyles,\n      oldCurrentStyles,\n      oldCurrentVelocities,\n      oldCurrentStyles, // oldLastIdealStyles really\n      oldCurrentVelocities, // oldLastIdealVelocities really\n    );\n\n    return {\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n      mergedPropsStyles,\n    };\n  }\n\n  // after checking for unreadPropStyles != null, we manually go set the\n  // non-interpolating values (those that are a number, without a spring\n  // config)\n  clearUnreadPropStyle = (unreadPropStyles: Array<TransitionStyle>): void => {\n    let [\n      mergedPropsStyles,\n      currentStyles,\n      currentVelocities,\n      lastIdealStyles,\n      lastIdealVelocities,\n    ] = mergeAndSync(\n      (this.props.willEnter: any),\n      (this.props.willLeave: any),\n      (this.props.didLeave: any),\n      this.state.mergedPropsStyles,\n      unreadPropStyles,\n      this.state.currentStyles,\n      this.state.currentVelocities,\n      this.state.lastIdealStyles,\n      this.state.lastIdealVelocities,\n    );\n\n    for (let i = 0; i < unreadPropStyles.length; i++) {\n      const unreadPropStyle = unreadPropStyles[i].style;\n      let dirty = false;\n\n      for (let key in unreadPropStyle) {\n        if (!Object.prototype.hasOwnProperty.call(unreadPropStyle, key)) {\n          continue;\n        }\n\n        const styleValue = unreadPropStyle[key];\n        if (typeof styleValue === 'number') {\n          if (!dirty) {\n            dirty = true;\n            currentStyles[i] = { ...currentStyles[i] };\n            currentVelocities[i] = { ...currentVelocities[i] };\n            lastIdealStyles[i] = { ...lastIdealStyles[i] };\n            lastIdealVelocities[i] = { ...lastIdealVelocities[i] };\n            mergedPropsStyles[i] = {\n              key: mergedPropsStyles[i].key,\n              data: mergedPropsStyles[i].data,\n              style: { ...mergedPropsStyles[i].style },\n            };\n          }\n          currentStyles[i][key] = styleValue;\n          currentVelocities[i][key] = 0;\n          lastIdealStyles[i][key] = styleValue;\n          lastIdealVelocities[i][key] = 0;\n          mergedPropsStyles[i].style[key] = styleValue;\n        }\n      }\n    }\n\n    // unlike the other 2 components, we can't detect staleness and optionally\n    // opt out of setState here. each style object's data might contain new\n    // stuff we're not/cannot compare\n    this.setState({\n      currentStyles,\n      currentVelocities,\n      mergedPropsStyles,\n      lastIdealStyles,\n      lastIdealVelocities,\n    });\n  };\n\n  startAnimationIfNecessary = (): void => {\n    if (this.unmounting || this.animationID != null) {\n      return;\n    }\n\n    // TODO: when config is {a: 10} and dest is {a: 10} do we raf once and\n    // call cb? No, otherwise accidental parent rerender causes cb trigger\n    this.animationID = defaultRaf(timestamp => {\n      // https://github.com/chenglou/react-motion/pull/420\n      // > if execution passes the conditional if (this.unmounting), then\n      // executes async defaultRaf and after that component unmounts and after\n      // that the callback of defaultRaf is called, then setState will be called\n      // on unmounted component.\n      if (this.unmounting) {\n        return;\n      }\n\n      const propStyles = this.props.styles;\n      let destStyles: Array<TransitionStyle> =\n        typeof propStyles === 'function'\n          ? propStyles(\n              rehydrateStyles(\n                this.state.mergedPropsStyles,\n                this.unreadPropStyles,\n                this.state.lastIdealStyles,\n              ),\n            )\n          : propStyles;\n\n      // check if we need to animate in the first place\n      if (\n        shouldStopAnimationAll(\n          this.state.currentStyles,\n          destStyles,\n          this.state.currentVelocities,\n          this.state.mergedPropsStyles,\n        )\n      ) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.accumulatedTime = 0;\n        return;\n      }\n\n      const currentTime = timestamp || defaultNow();\n      const timeDelta = currentTime - this.prevTime;\n      this.prevTime = currentTime;\n      this.accumulatedTime = this.accumulatedTime + timeDelta;\n      // more than 10 frames? prolly switched browser tab. Restart\n      if (this.accumulatedTime > msPerFrame * 10) {\n        this.accumulatedTime = 0;\n      }\n\n      if (this.accumulatedTime === 0) {\n        // no need to cancel animationID here; shouldn't have any in flight\n        this.animationID = null;\n        this.startAnimationIfNecessary();\n        return;\n      }\n\n      let currentFrameCompletion =\n        (this.accumulatedTime -\n          Math.floor(this.accumulatedTime / msPerFrame) * msPerFrame) /\n        msPerFrame;\n      const framesToCatchUp = Math.floor(this.accumulatedTime / msPerFrame);\n\n      let [\n        newMergedPropsStyles,\n        newCurrentStyles,\n        newCurrentVelocities,\n        newLastIdealStyles,\n        newLastIdealVelocities,\n      ] = mergeAndSync(\n        (this.props.willEnter: any),\n        (this.props.willLeave: any),\n        (this.props.didLeave: any),\n        this.state.mergedPropsStyles,\n        destStyles,\n        this.state.currentStyles,\n        this.state.currentVelocities,\n        this.state.lastIdealStyles,\n        this.state.lastIdealVelocities,\n      );\n      for (let i = 0; i < newMergedPropsStyles.length; i++) {\n        const newMergedPropsStyle = newMergedPropsStyles[i].style;\n        let newCurrentStyle: PlainStyle = {};\n        let newCurrentVelocity: Velocity = {};\n        let newLastIdealStyle: PlainStyle = {};\n        let newLastIdealVelocity: Velocity = {};\n\n        for (let key in newMergedPropsStyle) {\n          if (!Object.prototype.hasOwnProperty.call(newMergedPropsStyle, key)) {\n            continue;\n          }\n\n          const styleValue = newMergedPropsStyle[key];\n          if (typeof styleValue === 'number') {\n            newCurrentStyle[key] = styleValue;\n            newCurrentVelocity[key] = 0;\n            newLastIdealStyle[key] = styleValue;\n            newLastIdealVelocity[key] = 0;\n          } else {\n            let newLastIdealStyleValue = newLastIdealStyles[i][key];\n            let newLastIdealVelocityValue = newLastIdealVelocities[i][key];\n            for (let j = 0; j < framesToCatchUp; j++) {\n              [newLastIdealStyleValue, newLastIdealVelocityValue] = stepper(\n                msPerFrame / 1000,\n                newLastIdealStyleValue,\n                newLastIdealVelocityValue,\n                styleValue.val,\n                styleValue.stiffness,\n                styleValue.damping,\n                styleValue.precision,\n              );\n            }\n            const [nextIdealX, nextIdealV] = stepper(\n              msPerFrame / 1000,\n              newLastIdealStyleValue,\n              newLastIdealVelocityValue,\n              styleValue.val,\n              styleValue.stiffness,\n              styleValue.damping,\n              styleValue.precision,\n            );\n\n            newCurrentStyle[key] =\n              newLastIdealStyleValue +\n              (nextIdealX - newLastIdealStyleValue) * currentFrameCompletion;\n            newCurrentVelocity[key] =\n              newLastIdealVelocityValue +\n              (nextIdealV - newLastIdealVelocityValue) * currentFrameCompletion;\n            newLastIdealStyle[key] = newLastIdealStyleValue;\n            newLastIdealVelocity[key] = newLastIdealVelocityValue;\n          }\n        }\n\n        newLastIdealStyles[i] = newLastIdealStyle;\n        newLastIdealVelocities[i] = newLastIdealVelocity;\n        newCurrentStyles[i] = newCurrentStyle;\n        newCurrentVelocities[i] = newCurrentVelocity;\n      }\n\n      this.animationID = null;\n      // the amount we're looped over above\n      this.accumulatedTime -= framesToCatchUp * msPerFrame;\n\n      this.setState({\n        currentStyles: newCurrentStyles,\n        currentVelocities: newCurrentVelocities,\n        lastIdealStyles: newLastIdealStyles,\n        lastIdealVelocities: newLastIdealVelocities,\n        mergedPropsStyles: newMergedPropsStyles,\n      });\n\n      this.unreadPropStyles = null;\n\n      this.startAnimationIfNecessary();\n    });\n  };\n\n  componentDidMount() {\n    this.prevTime = defaultNow();\n    this.startAnimationIfNecessary();\n  }\n\n  UNSAFE_componentWillReceiveProps(props: TransitionProps) {\n    if (this.unreadPropStyles) {\n      // previous props haven't had the chance to be set yet; set them here\n      this.clearUnreadPropStyle(this.unreadPropStyles);\n    }\n\n    const styles = props.styles;\n    if (typeof styles === 'function') {\n      this.unreadPropStyles = styles(\n        rehydrateStyles(\n          this.state.mergedPropsStyles,\n          this.unreadPropStyles,\n          this.state.lastIdealStyles,\n        ),\n      );\n    } else {\n      this.unreadPropStyles = styles;\n    }\n\n    if (this.animationID == null) {\n      this.prevTime = defaultNow();\n      this.startAnimationIfNecessary();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unmounting = true;\n    if (this.animationID != null) {\n      defaultRaf.cancel(this.animationID);\n      this.animationID = null;\n    }\n  }\n\n  render(): ReactElement {\n    const hydratedStyles = rehydrateStyles(\n      this.state.mergedPropsStyles,\n      this.unreadPropStyles,\n      this.state.currentStyles,\n    );\n    const renderedChildren = this.props.children(hydratedStyles);\n    return renderedChildren && React.Children.only(renderedChildren);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}